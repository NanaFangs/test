#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 整数的二进制有三种
// 表示方法：原码、反码、补码
// 正整数的二进制表示方法是唯一的，但负整数有三种表示方法：原码、反码和补码。
// 1. 原码：符号位+数值位
// 2. 反码：符号位不变，数值位取反
// 3. 补码：符号位不变，数值位取反后加1
// ex:7 int 4 bytes = 32 bits
// 原码：0000 0000 0000 0000 0000 0000 0000 0111
// 反码：0000 0000 0000 0000 0000 0000 0000 0111
// 补码：0000 0000 0000 0000 0000 0000 0000 0111

//ex:-7
// 原码：1000 0000 0000 0000 0000 0000 0000 0111
// 反码：1111 1111 1111 1111 1111 1111 1111 1000
// 补码：1111 1111 1111 1111 1111 1111 1111 1001


//struct
// 结构体指针访问成员运算符 ->
// 结构体指针解引用运算符 *
// .
// 结构体指针访问成员运算符 -> 是对结构体指针的简化写法，等价于 (*s).name, (*s).age, (*s).score
struct Stu {
	char name[20];
	int age;
	double score;
};
void setStu(struct Stu* s, const char* name, int age, double score) {
	if (s == NULL) return; // 检查指针是否为NULL
	strcpy(s->name, name); 
	s->name[sizeof(s->name) - 1] = '\0'; // 确保字符串以'\0'结尾
	s->age = age;
	s->score = score;
}
void printStu(struct Stu* s) {
	//->
	// 结构体指针访问成员运算符
	printf("Name: %s, Age: %d, Score: %.2f\n", s->name, s->age, s->score);
	// 或者使用 (*s).name, (*s).age, (*s).score
	//. 结构体指针解引用运算符
	// 结构体指针解引用后访问成员
	//s->name 等价于 (*s).name
	printf("Name: %s, Age: %d, Score: %.2f\n", (*s).name, (*s).age, (*s).score);
}
//no pointer
void printStuNoPointer(struct Stu s) {
	// 直接访问结构体成员
	printf("Name: %s, Age: %d, Score: %.2f\n", s.name, s.age, s.score);
}
int main(){
	//<< >> 位移运算符移动的是补码 
	//<< 左移运算符：将二进制数向左移动指定的位数，右侧补0
	//int a = 7; // binary 0000 0000 0000 0000 0000 0000 0000 0111
	//int b = a << 1; // binary 1110 (14 in decimal)
	//printf("a = %d, b = %d\n", a, b);

	//int a1 = -7; // binary 1111 1111 1111 1111 1111 1111 1111 1001
	//int b1 = a1 << 1; // binary 1111 1111 1111 1111 1111 1111 1111 0010 (-14)-> [0010-1=0001]--[1110]=1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 14
	//printf("a1 = %d, b1 = %d\n", a1, b1);

	// >> 右移运算符：将二进制数向右移动指定的位数，左侧补符号位
	// 对于正数，左侧补0；对于负数，左侧补1
	// 注意：右移运算符的行为在不同编译器中可能有所不同，特别是对于负数。
	// 在C语言中，右移运算符通常是算术右移（即符号位扩展），但在某些情况下可能是逻辑右移,逻辑右移左侧直接补0。
	// 对于负数，右移时符号位会被复制
	// 例如：-7 的补码是 1111 1111 1111 1111 1111 1111 1111 1001
	// 右移1位后，变成 1111 1111 1111 1111 1111 1111 1111 1100
	//int a2 = 7; // binary 0000 0000 0000 0000 0000 0000 0000 0111
	//int b2 = a2 >> 1; // binary 0000 0000 0000 0000 0000 0000 0000 0011
	//printf("a2 = %d, b2 = %d\n", a2, b2);

	//int a3 = -7; // binary 1111 1111 1111 1111 1111 1111 1111 1001
	//int b3 = a3 >> 1; // binary 1111 1111 1111 1111 1111 1111 1111 1100  (-4)
	//printf("a3 = %d, b3 = %d\n", a3, b3);

	// & 按位与运算符：对两个二进制数的每一位进行与操作
	// 只有当两个对应位都为1时，结果才为1，否则为0
	//int a = 3; // binary 0000 0000 0000 0000 0000 0000 0000 0011
	//int b = -5; // binary 1111 1111 1111 1111 1111 1111 1111 1011
	//int c = a & b;
	//printf("a = %d, b = %d, c = %d\n", a, b, c);
	// 结果：c = 0000 0000 0000 0000 0000 0000 0000 0011 & 1111 1111 1111 1111 1111 1111 1111 1011 = 0000 0000 0000 0000 0000 0000 0000 0011

	// | 按位或运算符：对两个二进制数的每一位进行或操作
	// 只要有一个对应位为1，结果就为1，否则为0
	//int a1 = 3; // binary 0000 0000 0000 0000 0000 0000 0000 0011
	//int b1 = -5; // binary 1111 1111 1111 1111 1111 1111 1111 1011
	//int c1 = a1 | b1;
	//printf("a1 = %d, b1 = %d, c1 = %d\n", a1, b1, c1);
	// 结果：c1 = 0000 0000 0000 0000 0000 0000 0000 0011 | 1111 1111 1111 1111 1111 1111 1111 1011 = 1111 1111 1111 1111 1111 1111 1111 1011 : 1011-1=1010 -> 0101
	// 结果：c1 = -5

	
	// ^ 按位异或运算符：对两个二进制数的每一位进行异或操作
	// 当两个对应位不同（一个为1，一个为0）时，结果为1；当两个对应位相同（都为0或都为1）时，结果为0
	//int a2 = 3; // binary 0000 0000 0000 0000 0000 0000 0000 0011
	//int b2 = -5; // binary 1111 1111 1111 1111 1111 1111 1111 1011
	//int c2 = a2 ^ b2;
	//printf("a2 = %d, b2 = %d, c2 = %d\n", a2, b2, c2);
	// 结果：c2 = 0000 0000 0000 0000 0000 0000 0000 0011 ^ 1111 1111 1111 1111 1111 1111 1111 1011 = 1111 1111 1111 1111 1111 1111 1111 1000 : -8

	// two number swap
	//int x = 5, y = 10;
	//x = x ^ y; // x = 15 (binary 0000 0000 0000 0000 0000 0000 0000 1111) x=5^10
	//y = x ^ y; // y = 5 (binary 0000 0000 0000 0000 0000 0000 0000 0101) 5^10^10 = 5
	//x = x ^ y; // x = 10 (binary 0000 0000 0000 0000 0000 0000 0000 1010) 5^10^5 = 10
	//printf("After swap: x = %d, y = %d\n", x, y);
	// 结果：After swap: x = 10, y = 5

	//~ 按位取反运算符：对一个二进制数的每一位进行取反操作
	// 将0变为1，将1变为0
	//int a3 = 5; // binary 0000 0000 0000 0000 0000 0000 0000 0101
	//int b3 = ~a3; // binary 1111 1111 1111 1111 1111 1111 1111 1010
	//printf("a3 = %d, b3 = %d\n", a3, b3);
	// 结果：b3 = 1111 1111 1111 1111 1111 1111 1111 1010 : -6
	
	//sizeof 运算符：用于计算数据类型或变量所占的字节数

	//int a = 13; // binary 0000 0000 0000 0000 0000 0000 0000 1101
	//a |= (1 << 4); 
	//(1<<4) // binary 0000 0000 0000 0000 0000 0000 0001 0000
	//a |= (1 << 4); // binary 0000 0000 0000 0000 0000 0000 0001 1101
	//printf("a = %d\n", a); // 29
	//a &= ~(1 << 4);
	// ~(1 << 4) // binary 1111 1111 1111 1111 1111 1111 1110 0111
	// a &= ~(1 << 4); // binary 0000 0000 0000 0000 0000 0000 0000 1101

	//++ 
	//int a = 3;
	//int b = a++; // b = 3, a = 4  gives a to b then increment a
	//int c = ++a; // c = 5, a = 5  increment a then gives a to c
	//printf("a = %d, b = %d, c = %d\n", a, b, c); // a = 5, b = 3, c = 5

	//--
	//int a1 = 3;
	//int b1 = a1--; // b1 = 3, a1 = 2  gives a1 to b1 then decrement a1
	//int c1 = --a1; // c1 = 1, a1 = 1  decrement a1 then gives a1 to c1
	//printf("a1 = %d, b1 = %d, c1 = %d\n", a1, b1, c1); // a1 = 1, b1 = 3, c1 = 1

	//*
	//int a = 3;
	//int* p = &a; // p指向a的地址
	//*p = 5; // 修改p指向的地址的值，即修改a的值
	//printf("a = %d, *p = %d\n", a, *p); // a = 5, *p = 5
	//
	//int arr[] = { 1, 2, 3, 4, 5 };
	//int* pArr = arr; // pArr指向数组的首地址
	//*pArr = 10; // 修改pArr指向的地址的值，即修改数组的第一个元素
	//*(pArr + 1) = 20; // 修改pArr指向的地址的值，即修改数组的第二个元素
	//for (int i = 0; i < 5; i++) {
	//	printf("arr[%d] = %d\n", i, arr[i]); // arr[0] = 10, arr[1] = 20, arr[2] = 3, arr[3] = 4, arr[4] = 5
	//}

	//int a = 3.14; // 
	//int a = (int)3.14; // 强制类型转换，将3.14转换为整数3
	//printf("a = %d\n", a); // a = 3

	// ==
	/*if (3 == 5) {

	}
	if (3.0 == 5.0) {

	}*/

	// string 
	//strcmp("hello", "world"); // 字符串比较，返回0表示相等，非0表示不相等
	/*if ("hello"=="world") { this will compare two strng's address in the memory, not the content of the string
		printf("hello == world\n");
	} else {
		printf("hello != world\n");
	}*/

	//&& 
	// 逻辑与运算符：当且仅当两个操作数都为真时，结果才为真
	//int a = 3;
	//int b = 5;
	//int c = a && b; // c = 1 (true) 因为a和b都非0，所以c为1

	//// || 
	//// 逻辑或运算符：只要有一个操作数为真，结果就为真
	//int d = 0;
	//int e = 5;
	//int f = d || e; // f = 1 (true) 因为e非0，所以f为1

	//int i = 0, a = 0, b = 2, c = 3,d = 4;
	//i = a++ && ++b && d++; // a = 1, b = 2, c = 3, d = 4
	//// a++ 先把值=0，所以 a++&& 之后不用运算了
	//i = a++ || ++b || d++; // a = 1, b = 2, c = 3, d = 4
	//// a++ 先把值=1，所以 a++|| 之后不用运算了
	//printf("i = %d, a = %d, b = %d, c = %d, d = %d\n", i, a, b, c, d);
	//// i = 0, a = 1, b = 2, c = 3, d = 4

	// 三元运算符：exp1 ? exp2 : exp3
	//int a = 3, b = 5;
	//b = a > b ? a : b;
	//int max = (a > b) ? a : b; // 如果a大于b，则max为a，否则为b

	// , , ,
	// 逗号运算符：将多个表达式连接在一起，依次计算每个表达式，并返回最后一个表达式的值
	//int a = 1, b = 2, c = 3;
	//int c = (a > b, a += 10, a, b += a);
	//printf("a = %d, b = %d, c = %d\n", a, b, c); // // a = 11, b = 13, c = 13
	

     //struct
	//struct Stu student;
	//setStu(&student, "Alice", 20, 95.5);
	//printStu(&student);
	//printf(")))))))))))\n");
	//student.age = 21; // 修改结构体成员
	//printStuNoPointer(student);
	
	//char c = -1;
	//-1 binary 
	//1000 0000 0000 0000 0000 0000 0000 0001  ~
	//1111 1111 1111 1111 1111 1111 1111 1110  +1
	//1111 1111 1111 1111 1111 1111 1111 1111 
	// char is 1 byte = 8 bits
	// therefore, c is 1111 1111
	//convert char c to int , fill with the sign bit
	// int a = c;  a = -1, binary 1111 1111 1111 1111 1111 1111 1111 1111
	//char c1 = 1;
	//binary 0000 0000 0000 0000 0000 0000 0000 0001
	// c1 is 0000 0001
	//convert c1 to int, fill with the sign bit
	// int a = c1; a = 1, binary 0000 0000 0000 0000 0000 0000 0000 0001
	// if unsigned just fill with 0

	char a = 28;
	char b = 14;
	char c = a + b;
	// a = 28, binary 0001 1100
	// b = 14, binary 0000 1110
	// c = a + b, binary 0001 1100 + 0000 1110 = 0001 1010
	// c = 42, binary 0010 1010

	char a1 = 5;
	char b1 = 126;
	char c1 = a1 + b1;
	// a1 = 5, binary 0000 0101
	// 0000 0000 0000 0000 0000 0000 0000 0101
	// b1 = 126, binary 0111 1110
	// 0000 0000 0000 0000 0000 0000 0111 1110
	// a1+b1 = 
	// 0000 0000 0000 0000 0000 0000 1000 0011
	// c1=1000 0011
	// 1111 1111 1111 1111 1111 1111 1000 0011 - 补码 -1
	// 1111 1111 1111 1111 1111 1111 1000 0010 - 反码
	// 1000 0000 0000 0000 0000 0000 0111 1101 - 原码  =-125
	
	
	printf("a = %d, b = %d, c = %d\n", a, b, c); // a = 28, b = 14, c = 42
	printf("a1 = %d, b1 = %d, c1 = %d\n", a1, b1, c1); // a1 = 5, b1 = 126, c1 = -125




	
	
	return 0;
}